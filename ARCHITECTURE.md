# Corpus Architecture

## Opening
Corpus is a personal CV operating system expressed through two surfaces that share a single conceptual model. The extension is the active product surface for day-to-day work, where CV types are authored, versioned, and exported into Google Drive. The web project remains in the repository as a legacy reference implementation that captures earlier interaction decisions and domain logic, which still helps explain why the data model looks the way it does today.

At its core, Corpus treats a CV as a living artifact rather than a static file. A user maintains named CV types, each type contains editable data and a set of explicit version snapshots, and each version can be exported to a stable Drive file link. Visibility is resolved at field granularity so export output can vary by audience without duplicating entire documents. The architecture is designed around this idea that authoring, versioning, and deployment are one continuous flow.

## Ontology
The central entity in the system is the state document represented by `corpus-state-v2.json`, which lives in Drive `appDataFolder` and mirrors the in-memory structure used by the UI. Inside that state, a CV type is the long-lived container that owns current editable form data, type-level field visibility defaults, and a list of historical versions. A version is an immutable snapshot of CV data at a specific moment, coupled with per-field override visibility so one version can include or suppress content independently of type defaults.

Drive export records form another important entity because they bind a `(cvTypeId, versionId)` pair to a stable Drive PDF file identity. This lets repeated exports update the same file instead of generating link churn. Links dashboard entries are lightweight entities that store arbitrary URL shortcuts, and settings entities hold the folder IDs that anchor Drive path reuse. In the UI layer, local drafts are transient entities that exist only to preserve unsynced edits and shield typing from network latency.

## Geography
The repository root holds coordination documents and two codebases. The `docs/` directory carries product specs that describe intent and acceptance criteria. The `extension/` directory contains the Chrome extension runtime and is the active implementation. Inside `extension/src/background`, `service_worker.js` is the command boundary that normalizes auth, validation, and persistence operations for every UI request. Inside `extension/src/drive`, `auth.js` manages OAuth token lifecycle, `client.js` owns raw Drive API request mechanics, and `repository.js` translates storage intent into Drive file and folder operations.

The `extension/src/common` directory defines shared domain behavior. `schema.js` is the schema authority for field keys and state sanitization, `migration.js` upgrades legacy payloads into v2 shape, `visibility.js` computes effective field-level visibility and filtered data views, and `pdf.js` converts a version snapshot into printable text lines and bytes. The `extension/src/ui` directory contains UI surfaces and orchestration. `app.js` is the editor controller, `popup.js` is the compact deploy utility, `runtime.js` is the messaging adapter, and `styles.css` is the shared visual language. Supporting UI modules such as `sync_controller.js`, `lifecycle_flush.js`, and `perf.js` isolate local-first synchronization policy, lifecycle flush wiring, and optional instrumentation.

The `web/` directory is the legacy web studio implementation. In `web/src`, `app.js` drives rendering and interactions, `core.js` contains pure helper logic for model transforms and validation, and `styles.css` plus `index.html` define the presentation shell. Even though extension-first delivery is the current path, this project remains useful for historical behavior reference and regression comparison.

The extension also carries an explicit verification layer in `extension/tests`, where state migration, Drive behavior, runtime error normalization, popup sorting logic, and sync-controller lifecycle handling are exercised with deterministic unit tests. Build and packaging behavior is defined in `extension/scripts/build.mjs`, which copies source assets into `dist/` and can produce a zip artifact for Chrome distribution.

## Flow
A typical extension session begins with UI startup in `app.js`, which asks the background worker for `STATE_LOAD` through `runtime.js`. The service worker validates auth, loads and sanitizes state through the repository, and returns a normalized payload. The editor then overlays any unsynced local drafts from `chrome.storage.local` so the user sees the latest authored content immediately even before network reconciliation completes.

When the user edits fields, the UI mutates local in-memory data first and schedules local draft persistence plus delayed Drive sync through `sync_controller.js`. This local-first branch is intentionally decoupled from render cycles so typing remains responsive. The controller coalesces overlapping edits, enforces single-flight sync behavior, retries once on state conflict after reloading remote state, and preserves drafts on failure. Lifecycle signals such as tab hide and unload trigger best-effort flush requests so pending edits are pushed whenever the environment allows.

When the user creates versions or exports PDFs, the editor first requests a sync flush to reduce the risk of snapshotting stale state. Version creation then happens in the service worker against canonical state, producing a new immutable record with inherited visibility overrides. Export requests resolve field visibility, build PDF bytes through `pdf.js`, and write to Drive via repository methods that reuse prior file IDs when available. This preserves stable links for repeated submissions while keeping export content aligned with current visibility policy.

## Philosophy
Corpus deliberately concentrates state authority in one normalized schema and one command boundary. This choice trades some convenience for predictability: every path that mutates data passes through the same sanitization and error normalization rules, which keeps behavior coherent across popup and editor surfaces. The move to local-first sync accepts eventual consistency over immediate remote persistence because perceived responsiveness is more important than sub-second Drive writes for personal authoring workflows.

The repository also embraces explicit seams between intent and transport. UI code expresses user intent, background code enforces command contracts, repository code expresses persistence goals, and Drive client code handles protocol details. This layering is not ornamental; it makes failures legible and testable. Narration and architecture documents are treated as first-class artifacts because this project is meant to be understood as a system, not just executed as code.
